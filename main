// ==UserScript==
// @name         Advanced Reddit Bot & AI Detector with Advanced Heuristics (Fractional Weights)
// @namespace    http://tampermonkey.net/
// @version      2.2.1
// @description  Detects suspected bot and AI-generated posts/comments on Reddit using advanced heuristics with fractional weights. Highlights flagged elements and displays a popup with details.
// @author       
// @match        https://www.reddit.com/*
// @match        https://old.reddit.com/*
// @grant        none
// ==/UserScript==

(function() {
    'use strict';

    /***********************
     * CONFIGURATION
     ***********************/
    const RED_FLAG_THRESHOLD = 4;  // Total score threshold for highlighting

    // --- Bot-related heuristics ---
    const suspiciousUserPatterns = [
        /bot/i,                               // Any username containing "bot"
        /^[A-Za-z]+-[A-Za-z]+\d{4}$/,          // e.g., "Vacuum-Wonder7569"
        /^[A-Za-z]+[A-Za-z]+\d+$/,             // Similar to default names missing hyphen
        /^[A-Z][a-z]+[A-Z][a-z]+s{2,}$/         // e.g., "MariaJamesss"
    ];

    function isRandomString(username) {
        if (username.length < 8) return false;
        const vowels = username.match(/[aeiou]/gi);
        const ratio = vowels ? vowels.length / username.length : 0;
        return ratio < 0.3;
    }

    const genericResponses = [
        "i agree dude",
        "yes you are right",
        "well said",
        "totally agree",
        "i agree",
        "right you are",
        "well spoken, you are",
        "perfectly said this is"
    ];

    const scamLinkRegex = /\.(live|life|shop)\b/i;

    function isNewAccount(userElem) {
        const titleAttr = userElem.getAttribute('title') || "";
        return /redditor for.*\b(day|week|month)\b/i.test(titleAttr);
    }

    // Global map to track duplicate comment texts.
    const commentTextMap = new Map();

    /***********************
     * ADVANCED AI DETECTION HEURISTICS (Fractional Weights)
     ***********************/
    function computeAIScore(text) {
        let score = 0;
        let lowerText = text.toLowerCase();

        // Heuristic 1: Explicit AI disclaimers (strong signal)
        if (lowerText.includes("as an ai language model") || lowerText.includes("i am not a human")) {
            score += 1.9;
        }

        // Heuristic 2: Lack of contractions in long texts
        let contractions = lowerText.match(/\b(i'm|you're|they're|we're|can't|won't|didn't|isn't|aren't)\b/g);
        let words = lowerText.split(/\s+/);
        let wordCount = words.length;
        if (wordCount > 150 && (!contractions || contractions.length === 0)) {
            score += 1.2;
        }

        // Heuristic 3: Formal filler phrases
        const aiPhrases = ["in conclusion", "furthermore", "moreover", "on the other hand"];
        aiPhrases.forEach(phrase => {
            if (lowerText.includes(phrase)) {
                score += 1.1;
            }
        });

        // Heuristic 4: Common AI indicator phrases
        const aiIndicators = [
            "i do not have personal experiences",
            "my training data",
            "i cannot",
            "i do not have the ability",
            "apologies if",
            "i apologize",
            "i'm unable",
            "as an ai",
            "as an artificial intelligence"
        ];
        aiIndicators.forEach(phrase => {
            if (lowerText.includes(phrase)) {
                score += 1.3;
            }
        });

        // Heuristic 5: Repetitiveness / low burstiness
        let sentences = lowerText.split(/[.!?]+/).map(s => s.trim()).filter(s => s.length > 0);
        if (sentences.length > 1) {
            let lengths = sentences.map(s => s.split(/\s+/).length);
            let avg = lengths.reduce((a, b) => a + b, 0) / lengths.length;
            let variance = lengths.reduce((a, b) => a + Math.pow(b - avg, 2), 0) / lengths.length;
            if (variance < 4) { // very uniform sentence lengths
                score += 1.5;
            }
        }

        // Heuristic 6: Lexical Diversity
        let uniqueWords = new Set(words);
        let typeTokenRatio = uniqueWords.size / words.length;
        if (words.length > 20 && typeTokenRatio < 0.3) {
            score += 1.4;
        }

        // Heuristic 7: Bigram Uniqueness
        function getBigrams(arr) {
            let bigrams = [];
            for (let i = 0; i < arr.length - 1; i++) {
                bigrams.push(arr[i] + " " + arr[i+1]);
            }
            return bigrams;
        }
        let bigrams = getBigrams(words);
        if (bigrams.length > 0) {
            let uniqueBigrams = new Set(bigrams);
            let bigramRatio = uniqueBigrams.size / bigrams.length;
            if (bigramRatio < 0.5) {
                score += 1.3;
            }
        }

        // Additional Heuristic: Syntactic Complexity via punctuation variability.
        function computeSyntaxScore(text) {
            let sentences = text.split(/[.!?]+/).map(s => s.trim()).filter(s => s.length > 0);
            if (sentences.length === 0) return 0;
            let punctuationMatches = text.match(/[,\;:\-]/g);
            let punctuationCount = punctuationMatches ? punctuationMatches.length : 0;
            let avgPunctuation = punctuationCount / sentences.length;
            return avgPunctuation < 1 ? 1.1 : 0;
        }
        score += computeSyntaxScore(text);

        return score;
    }

    /***********************
     * BOT SCORE (Non-AI) CALCULATION
     ***********************/
    function computeBotScore(elem) {
        let score = 0;
        const userElem = elem.querySelector('a[href*="/user/"]');
        if (userElem) {
            const username = userElem.innerText.trim();
            if (username) {
                if (username.toLowerCase().includes("bot")) {
                    score++;
                }
                suspiciousUserPatterns.forEach(pattern => {
                    if (pattern.test(username)) {
                        score++;
                    }
                });
                if (isRandomString(username)) {
                    score++;
                }
            }
            if (isNewAccount(userElem)) {
                score++;
            }
        }

        let textContent = elem.innerText.toLowerCase().replace(/\s+/g, ' ').trim();
        genericResponses.forEach(phrase => {
            if (textContent === phrase) {
                score++;
            }
        });
        if (textContent.split(' ').length < 3) {
            score++;
        }
        if (textContent.includes("&amp;") && !textContent.includes("& ")) {
            score++;
        }
        if (textContent.startsWith('>') && textContent.split(' ').length < 5) {
            score++;
        }
        if (textContent.length > 0) {
            const count = commentTextMap.get(textContent) || 0;
            if (count > 0) {
                score++;
            }
        }

        const links = elem.querySelectorAll('a');
        links.forEach(link => {
            if (scamLinkRegex.test(link.href)) {
                score++;
            }
            if (link.parentElement && link.parentElement.innerText.includes("Powered by Gearlaunch")) {
                score++;
            }
        });
        return score;
    }

    // Combined scoring: total score = botScore + aiScore.
    function countRedFlags(elem) {
        const botScore = computeBotScore(elem);
        const aiScore = computeAIScore(elem.innerText);
        return { botScore, aiScore, totalScore: botScore + aiScore };
    }

    /***********************
     * HIGHLIGHTING & RECORDING DETECTIONS
     ***********************/
    let botCount = 0;
    let detectedBots = []; // Records detections with username, snippet, and reason.

    function createPopup() {
        let popup = document.getElementById("botCounterPopup");
        if (!popup) {
            popup = document.createElement("div");
            popup.id = "botCounterPopup";
            popup.style.position = "fixed";
            popup.style.top = "10px";
            popup.style.right = "10px";
            popup.style.backgroundColor = "#f8f8f8";
            popup.style.border = "1px solid #ccc";
            popup.style.padding = "10px";
            popup.style.zIndex = "9999";
            popup.style.fontFamily = "Arial, sans-serif";
            popup.style.fontSize = "14px";
            popup.style.cursor = "pointer";
            popup.style.width = "250px";

            let header = document.createElement("div");
            header.id = "botPopupHeader";
            header.innerText = "Detected bot/AI content: " + botCount;
            popup.appendChild(header);

            let dropdown = document.createElement("div");
            dropdown.id = "botDropdown";
            dropdown.style.display = "none";
            dropdown.style.maxHeight = "300px";
            dropdown.style.overflowY = "auto";
            dropdown.style.marginTop = "10px";
            dropdown.style.borderTop = "1px solid #ccc";
            dropdown.style.paddingTop = "5px";
            popup.appendChild(dropdown);

            popup.addEventListener("click", function(e) {
                e.stopPropagation();
                dropdown.style.display = (dropdown.style.display === "none") ? "block" : "none";
            });

            document.body.appendChild(popup);
        }
    }

    function updatePopup() {
        let header = document.getElementById("botPopupHeader");
        let dropdown = document.getElementById("botDropdown");
        if (header) {
            header.innerText = "Detected bot/AI content: " + botCount;
        }
        if (dropdown) {
            dropdown.innerHTML = "";
            if (detectedBots.length === 0) {
                let emptyMsg = document.createElement("div");
                emptyMsg.innerText = "No bots/AI detected.";
                dropdown.appendChild(emptyMsg);
            } else {
                detectedBots.forEach(function(item) {
                    let entry = document.createElement("div");
                    entry.style.marginBottom = "5px";
                    entry.innerHTML = "<strong>" + item.username + ":</strong> " + item.comment +
                                        " (" + item.reason + ")";
                    dropdown.appendChild(entry);
                });
            }
        }
    }

    createPopup();
    updatePopup();

    function highlightIfSuspected(elem) {
        if (elem.getAttribute("data-bot-detected") === "true") {
            return;
        }
        const scores = countRedFlags(elem);
        if (scores.totalScore >= RED_FLAG_THRESHOLD) {
            let reason;
            if (scores.botScore > 0 && scores.aiScore > 0) {
                reason = "Bot/AI";
            } else if (scores.aiScore > 0) {
                reason = "AI";
            } else {
                reason = "Bot";
            }
            // Apply outline based on detection reason.
            if (reason === "Bot") {
                elem.style.outline = "3px dashed red";
            } else if (reason === "AI") {
                elem.style.outline = "3px dashed blue";
            } else {
                elem.style.outline = "3px dashed purple";
            }
            elem.setAttribute("data-bot-detected", "true");
            botCount++;
            if (!elem.getAttribute("data-bot-recorded")) {
                let userElem = elem.querySelector('a[href*="/user/"]');
                let username = userElem ? userElem.innerText.trim() : "Unknown";
                let comment = elem.innerText.trim();
                if (comment.length > 100) {
                    comment = comment.substring(0, 100) + "...";
                }
                detectedBots.push({ username: username, comment: comment, reason: reason });
                elem.setAttribute("data-bot-recorded", "true");
            }
            updatePopup();
            console.log("Advanced Detector: Highlighted element with", scores.totalScore, "red flags.");
        }
    }

    function scanForBots(root = document) {
        const selectors = [
            'div[data-testid="post-container"]', // new Reddit posts
            'div[data-testid="comment"]',          // new Reddit comments
            'div.thing',                           // old Reddit posts/comments
            'div.Comment'                          // additional new Reddit container
        ];
        const candidates = root.querySelectorAll(selectors.join(', '));
        candidates.forEach(candidate => {
            let textContent = candidate.innerText.toLowerCase().replace(/\s+/g, ' ').trim();
            if (textContent.length > 0) {
                const currentCount = commentTextMap.get(textContent) || 0;
                commentTextMap.set(textContent, currentCount + 1);
            }
            highlightIfSuspected(candidate);
        });
    }

    /***********************
     * INITIALIZATION & DYNAMIC OBSERVATION
     ***********************/
    scanForBots();

    const observer = new MutationObserver(mutations => {
        mutations.forEach(mutation => {
            mutation.addedNodes.forEach(node => {
                if (node.nodeType === Node.ELEMENT_NODE) {
                    scanForBots(node);
                }
            });
        });
    });
    observer.observe(document.body, { childList: true, subtree: true });

    setInterval(() => {
        scanForBots(document);
    }, 3000);

})();
