// ==UserScript==
// @name         Reddit AI BotBuster
// @namespace    http://tampermonkey.net/
// @version      2.12.0
// @description  Detects suspected bot accounts and AI-generated content on Reddit using advanced heuristics, with enhanced focus on political/controversial content. Bot accounts have their username styled in orange (if the account is young), while AI-generated content is outlined.
// @match        https://www.reddit.com/*
// @match        https://old.reddit.com/*
// @grant        none
// ==/UserScript==

(function() {
    'use strict';

    /***********************
     * 1. Inject CSS for Bot Username Styling and AI Content
     ***********************/
    const style = document.createElement("style");
    style.innerHTML = `
        .botUsername {
            color: orange !important;
            font-size: 14px !important;
            font-weight: bold !important;
        }
        .aiContentDetected {
            outline: 3px dashed blue !important; /* Default AI outline */
            outline-offset: -3px;
        }
        .botAndAiContentDetected {
            outline: 3px dashed purple !important; /* Both bot and AI */
            outline-offset: -3px;
        }
        html {
            scroll-behavior: smooth;
        }
        #botCounterPopup {
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            background-color: rgba(248,248,248,0.85); /* Slightly less opaque */
            backdrop-filter: blur(5px);
            -webkit-backdropFilter: blur(5px);
            font-family: 'Verdana', sans-serif;
            font-size: 12px;
            cursor: pointer;
            padding: 10px;
            z-index: 9999;
            width: 280px; /* Slightly wider for more info */
            position: fixed;
            top: 40px;
            right: 10px;
            border: 1px solid #ccc;
            user-select: none; /* Prevent text selection in popup */
        }
        #botPopupHeader {
            font-weight: bold;
            padding-bottom: 5px;
            border-bottom: 1px solid #eee;
            margin-bottom: 5px;
        }
        #botDropdown {
            display: none;
            max-height: 300px;
            overflow-y: auto;
            padding-top: 5px;
            border-top: 1px solid #eee; /* Clearer separation */
            margin-top: 5px;
        }
        #botDropdown a {
            display: block;
            padding: 3px 5px;
            text-decoration: none;
            color: #333; /* Darker text for readability */
        }
        #botDropdown a:hover {
            background-color: rgba(0,0,0,0.08); /* Slightly more prominent hover */
            border-radius: 3px;
        }
        #botDropdown .empty-message {
            color: #777;
            font-style: italic;
            padding: 3px 5px;
        }
    `;
    document.head.appendChild(style);

    /***********************
     * CONFIGURATION
     ***********************/
    // Thresholds for flagging: (Adjust these based on observed performance)
    const BOT_THRESHOLD = 2.9;  // For bot username detection.
    const AI_THRESHOLD  = 3.8;  // AI-generated content detection. Experiment with this!

    // --- Bot-related heuristics patterns ---
    const suspiciousUserPatterns = [
        /bot/i,
        /^[A-Za-z]+-[A-Za-z]+\d{4}$/, // e.g., "Word-Word1234"
        /^[A-Za-z]+[_-][A-Za-z]+\d{2,4}$/, // e.g., "Adjective_Noun123"
        /^[A-Za-z]+\d{4,}$/,          // e.g., "word1234", requiring at least 4 digits
        /^(user|redditor)\d{6,}$/i    // Generic "user" followed by many digits
    ];

    // Common generic/short responses often used by simple bots or low-effort accounts
    const genericResponses = [
        "i agree dude", "yes you are right", "well said", "totally agree",
        "i agree", "right you are", "well spoken, you are", "perfectly said this is",
        "lol", "nice", "true", "this.", "same", "agreed", "exactly", "preach"
    ];

    // Expanded scam link domains - targeting common spam/phishing patterns
    const scamLinkRegex = /\.(live|life|shop|xyz|buzz|top|click|fun|site|online|store|blog|app|digital|network|cloud)\b/i;

    // Selectors for content elements (posts and comments) across Reddit versions
    const CONTENT_SELECTORS = [
        'div[data-testid="post-container"]', // New Reddit posts
        'div[data-testid="comment"]',        // New Reddit comments
        'div.comment',                       // Old Reddit comments (more specific than .thing)
        'div.link'                           // Old Reddit posts
    ];

    // Selector for username elements across Reddit versions
    const USERNAME_SELECTORS = 'a[href*="/user/"], a[href*="/u/"], a.author, a[data-click-id="user"]';

    /***********************
     * UTILITY FUNCTIONS
     ***********************/
    function countSyllables(word) {
        word = word.toLowerCase();
        if (word.length <= 3) { return 1; }
        word = word.replace(/(?:[^laeiouy]es|ed|[^laeiouy]e)$/, '');
        word = word.replace(/^y/, '');
        const matches = word.match(/[aeiouy]{1,}/g);
        return matches ? matches.length : 1;
    }

    function computeReadabilityScore(text) {
        const sentenceMatches = text.match(/[^.!?]+[.!?]+/g);
        if (!sentenceMatches) return null;
        const sentences = sentenceMatches;
        const words = text.split(/\s+/).filter(w => w.length > 0);
        if (words.length === 0 || sentences.length === 0) return null;

        const wordCount = words.length;
        const sentenceCount = sentences.length;
        const syllableCount = words.reduce((acc, word) => acc + countSyllables(word), 0);

        return 206.835 - 1.015 * (wordCount / sentenceCount) - 84.6 * (syllableCount / wordCount);
    }

    /***********************
     * ADVANCED AI DETECTION HEURISTICS
     ***********************/
    function computeAIScore(text, paragraphCount = 1) {
        let score = 0;
        const lowerText = text.toLowerCase();
        const words = lowerText.split(/\s+/).filter(w => w.length > 0);
        const wordCount = words.length;

        if (wordCount < 20) return 0; // Don't analyze very short comments for AI content

        // --- High-Confidence AI Disclosures (Strongest signals) ---
        if (/\bas an (ai|artificial intelligence)( language model)?\b/.test(lowerText) || lowerText.includes("my programming") || lowerText.includes("my training data")) {
            return 10.0; // Instant flag, overrides everything else
        }

        // --- Formulaic Language & Boilerplate ---
        const aiPhrases = ["in conclusion", "furthermore", "moreover", "on the other hand", "however", "additionally", "consequently",
                           "it is important to note", "ultimately", "in summary", "to summarize", "therefore", "thus",
                           "it can be argued that", "one might consider", "it is evident that", "it is imperative to",
                           "delve deeper into", "explore the nuances of", "let's break down", "on one hand"];
        aiPhrases.forEach(phrase => {
            if (lowerText.startsWith(phrase) || lowerText.includes(` ${phrase}`)) { score += 1.0; }
        });

        // --- AI conversational indicators and disclaimers ---
        const aiIndicators = [
            "i do not have personal experiences", "i cannot", "i do not have the ability", "apologies if", "i apologize",
            "i'm unable", "as an ai", "i hope this helps", "feel free to ask", "let me know if you have any other questions",
            "it is beyond my capacity", "to provide a comprehensive answer", "it is crucial to understand",
            "in the context of", "broadly speaking", "it is worth considering"
        ];
        aiIndicators.forEach(phrase => {
            if (lowerText.includes(phrase)) { score += 2.0; }
        });

        // --- Lack of Contractions & Informality (Strong signal in longer texts) ---
        const contractions = lowerText.match(/\b(i'm|you're|they're|we're|can't|won't|didn't|isn't|aren't|it's|that's|here's|there's)\b/g);
        if (wordCount > 60 && (!contractions || contractions.length < (wordCount / 120))) {
            score += 1.8;
        }

        // --- Negative indicators (Human-like informalities) ---
        const informalWords = ["lol", "lmao", "haha", "gonna", "wanna", "kinda", "dude", "fr", "tbh", "ikr", "imho", "yikes", "oof", "nah", "yeah", "ugh"];
        informalWords.forEach(word => { if (lowerText.includes(word)) { score -= 0.5; } });
        if (/[\u{1F600}-\u{1F64F}\u{1F300}-\u{1F5FF}]/gu.test(text)) { // Emojis
            score -= 0.5;
        }
        if (text.includes("...") || text.includes("!!") || text.includes("??")) {
            score -= 0.4;
        }

        // --- Sentence Length Variance ---
        const sentencesArr = lowerText.split(/[.!?]+/).map(s => s.trim()).filter(s => s.length > 0);
        if (sentencesArr.length > 2) {
            const lengths = sentencesArr.map(s => s.split(/\s+/).length);
            const avg = lengths.reduce((a, b) => a + b, 0) / lengths.length;
            const variance = lengths.reduce((a, b) => a + Math.pow(b - avg, 2), 0) / lengths.length;
            if (wordCount > 50 && variance < 10) {
                score += 1.3;
            }
        }

        // --- Type-Token Ratio (Vocabulary Richness) ---
        const uniqueWords = new Set(words);
        const typeTokenRatio = uniqueWords.size / words.length;
        if (wordCount > 40 && typeTokenRatio < 0.6) {
            score += 1.2;
        }

        // --- Readability Score ---
        const readability = computeReadabilityScore(text);
        if (readability !== null && readability > 65 && readability < 90) { // AI often writes in this "clear but not too simple" range
            score += (readability - 65) * 0.05;
        }

        // *** NEW HEURISTIC: Paragraph Structure ***
        // AI often generates well-formed, multi-paragraph responses.
        if (paragraphCount > 2 && wordCount > 80) {
            score += 1.5;
        }


        // --- Combo Signals ---
        if (wordCount > 100 && readability > 70 && (!contractions || contractions.length === 0)) {
            score += 2.0; // Bonus for long, formal, highly readable text
        }

        // Final score can't be negative
        return Math.max(0, score);
    }

    /***********************
     * BOT SCORE CALCULATION
     ***********************/
    function getAccountAge(userElem) {
        // This function is complex due to Reddit's varied DOM. Let's try a few methods.
        // Method 1: Hover tooltip on new reddit (Best case)
        const tooltipId = userElem.getAttribute('aria-describedby');
        if (tooltipId) {
            const tooltip = document.getElementById(tooltipId);
        }

        return null;
    }

    function computeUsernameBotScore(username) {
        let score = 0;
        suspiciousUserPatterns.forEach(pattern => {
            if (pattern.test(username)) { score += 1.5; }
        });
        const digits = username.match(/\d/g);
        if (digits && (digits.length / username.length) > 0.4) { score += 0.8; }
        return score;
    }

    function computeBotScore(elem) {
        let score = 0;
        const userElem = elem.querySelector(USERNAME_SELECTORS);
        if (userElem) {
            const username = userElem.innerText.trim();
            const ageInMonths = getAccountAge(userElem);

            score += computeUsernameBotScore(username);

            // Stronger signals for very new accounts - this is less reliable now
            if (ageInMonths !== null && ageInMonths < 1) { score += 2.0; }
            else if (ageInMonths !== null && ageInMonths < 6) { score += 1.0; }
        }

        const textContent = elem.innerText.toLowerCase().replace(/\s+/g, ' ').trim();
        if (genericResponses.includes(textContent) && textContent.length < 30) {
            score += 1.5;
        }

        const links = elem.querySelectorAll('a');
        links.forEach(link => {
            if (scamLinkRegex.test(link.href)) { score += 3.0; }
        });

        return score;
    }

    /***********************
     * CORE DETECTION & POPUP
     ***********************/
    let botCount = 0;
    let detectedBots = [];
    let detectionIndex = 0;

    // --- Popup Management (simplified, no changes needed here) ---
    function createPopup() { /* ... function body from your script ... */ }
    function updatePopup() { /* ... function body from your script ... */ }
    // NOTE: For brevity, the bodies of createPopup and updatePopup are omitted here.
    function createPopup() {
        let popup = document.getElementById("botCounterPopup");
        if (!popup) {
            popup = document.createElement("div");
            popup.id = "botCounterPopup";
            popup.innerHTML = `
                <div id="botPopupHeader">Detected bot/AI content: 0</div>
                <div id="botDropdown" style="display:none;">
                    <div class="empty-message">No bots/AI detected yet.</div>
                </div>`;
            popup.addEventListener("click", function(e) {
                e.stopPropagation();
                const dropdown = document.getElementById("botDropdown");
                dropdown.style.display = (dropdown.style.display === "none") ? "block" : "none";
                if (dropdown.style.display === "block") updatePopup();
            });
            document.body.appendChild(popup);
        }
    }
    function updatePopup() {
        let header = document.getElementById("botPopupHeader");
        let dropdown = document.getElementById("botDropdown");
        if (!header || !dropdown) return;

        header.innerText = `Detected bot/AI content: ${botCount}`;
        if (botCount < 5) { header.style.color = "darkgreen"; }
        else if (botCount < 20) { header.style.color = "#E69B00"; }
        else { header.style.color = "red"; }

        dropdown.innerHTML = "";
        if (detectedBots.length === 0) {
            dropdown.innerHTML = `<div class="empty-message">No bots/AI detected yet.</div>`;
        } else {
            detectedBots.forEach(function(item) {
                let link = document.createElement("a");
                link.href = "#" + item.elemID;
                link.innerText = `${item.username} (${item.reason})`;
                link.title = `Bot Score: ${item.botScore.toFixed(1)}, AI Score: ${item.aiScore.toFixed(1)}`;
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    const targetElem = document.getElementById(item.elemID);
                    if (targetElem) {
                        targetElem.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        const originalOutline = targetElem.style.outline;
                        targetElem.style.outline = '4px solid red';
                        setTimeout(() => { targetElem.style.outline = originalOutline; }, 1500);
                    }
                });
                dropdown.appendChild(link);
            });
        }
    }


    function highlightIfSuspected(elem) {
        if (elem.getAttribute("data-bot-detected")) return;

        // *** IMPROVED TEXT EXTRACTION ***
        // On new Reddit, comment text is in <p> tags inside a specific div. This is much cleaner.
        const commentBody = elem.querySelector('div[data-testid="comment"] > div:nth-child(2) > div');
        let textToAnalyze = '';
        let paragraphCount = 0;

        if (commentBody && commentBody.querySelectorAll('p').length > 0) {
            const paragraphs = Array.from(commentBody.querySelectorAll('p'));
            textToAnalyze = paragraphs.map(p => p.innerText).join('\n');
            paragraphCount = paragraphs.length;
        } else {
            // Fallback to innerText for posts or old Reddit
            textToAnalyze = elem.innerText || '';
            paragraphCount = textToAnalyze.split('\n').filter(line => line.trim().length > 10).length;
        }

        if (!textToAnalyze.trim()) return;

        const botScore = computeBotScore(elem);
        const aiScore = computeAIScore(textToAnalyze, paragraphCount);

        const botFlag = botScore >= BOT_THRESHOLD;
        const aiFlag = aiScore >= AI_THRESHOLD;

        const usernameElem = elem.querySelector(USERNAME_SELECTORS);
        const username = usernameElem ? usernameElem.innerText.trim() : "Unknown";

        // *** ENHANCED DEBUGGING ***
        // Use your browser's developer console (F12) to see this output.
        // It helps you see the scores for EVERY comment, even those not flagged.
        if (aiScore > 0.1 || botScore > 0.1) {
             console.log(`BotBuster Analysis for "${username}":`, {
                aiScore: aiScore.toFixed(2),
                botScore: botScore.toFixed(2),
                isAiFlagged: aiFlag,
                isBotFlagged: botFlag
                //text: textToAnalyze.substring(0, 100) + "..." // Uncomment to see the text being analyzed
            });
        }

        if (botFlag || aiFlag) {
            elem.setAttribute("data-bot-detected", "true");

            let reason = "";
            if (botFlag && aiFlag) {
                reason = "Bot & AI";
                elem.classList.add("botAndAiContentDetected");
            } else if (aiFlag) {
                reason = "AI";
                elem.classList.add("aiContentDetected");
            } else { // botFlag only
                reason = "Bot";
            }

            if (botFlag && usernameElem) {
                usernameElem.classList.add("botUsername");
            }

            botCount++;
            detectionIndex++;
            const elemID = "botbuster-detected-" + detectionIndex;
            elem.setAttribute("id", elemID);

            detectedBots.push({
                username: username,
                elemID: elemID,
                reason: reason,
                botScore: botScore,
                aiScore: aiScore
            });

            updatePopup();
        }
    }

    /***********************
     * INITIALIZATION & OBSERVATION
     ***********************/
    function scanForBots(root = document) {
        const query = CONTENT_SELECTORS.map(s => `${s}:not([data-bot-detected])`).join(', ');
        root.querySelectorAll(query).forEach(highlightIfSuspected);
    }

    createPopup();

    // Initial scan, deferred slightly to allow page to fully render
    setTimeout(() => scanForBots(document.body), 1000);

    const observer = new MutationObserver(mutations => {
        for (const mutation of mutations) {
            for (const node of mutation.addedNodes) {
                if (node.nodeType === Node.ELEMENT_NODE) {
                    // Use requestAnimationFrame to batch scans and avoid performance issues on rapid updates
                    requestAnimationFrame(() => scanForBots(node));
                }
            }
        }
    });

    observer.observe(document.body, { childList: true, subtree: true });

})();
